{% extends 'restaurant/base.html' %}

{% block title %}Dashboard Cocinero - AbbaHotel- Restaurante{% endblock %}

{% block body_class %}bg-gray-50 text-gray-800{% endblock %}

{% block extra_head %}
    <style>
        .order-card {
            transition: background-color 0.3s ease-in-out;
            border-left-width: 8px;
        }
        
        /* Colores de órdenes por antigüedad */
        .order-card-new { 
            border-color: #FBBF24;
            background-color: #FFFBEB;
        }
        .order-card-medium { 
            border-color: #D97706;
            background-color: #FEF3C7;
        }
        .order-card-old { 
            border-color: #92400E;
            background-color: #FED7AA;
        }
        .order-card-urgent {
            border-color: #EF4444;
            background-color: #FECACA;
        }
        .order-card-critical {
            border-color: #DC2626;
            background-color: #FCA5A5;
            animation: pulse-critical 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-critical {
            0%, 100% { background-color: #FCA5A5; }
            50% { background-color: #F87171; }
        }

        /* Ocultar la barra de scroll pero permitir el desplazamiento */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        /* Custom Toast Notification Styles */
        .toast {
            position: fixed;
            top: 5%;
            left: 50%;
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transform: translate(-50%, -100px);
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.875rem;
        }
        .toast.show {
            opacity: 1;
            transform: translate(-50%, 0);
        }
        .toast.success { color: #22c55e; }
        .toast.error { color: #ef4444; }
        .toast.info { color: #3b82f6; }
    </style>
{% endblock %}

{% block content %}
    <div class="fixed top-0 left-0 right-0 bg-white p-2 z-10 flex justify-between items-center border-b border-gray-200 shadow-sm">
        <h1 class="text-2xl font-bold text-gray-900">Panel de Cocina</h1>
        <a href="{% url 'logout' %}" class="text-sm text-red-600 hover:text-red-800">Cerrar Sesión</a>
    </div>
    
    <div class="flex h-screen pt-14">
        <!-- Columna de Pedidos Recibidos -->
        <div class="w-1/2 border-r border-gray-200 flex flex-col">
            <div class="p-4 border-b border-gray-200 bg-gray-100">
                <h2 class="text-2xl font-bold text-center text-amber-800">Recibidos</h2>
            </div>
            <div id="pending-orders" class="flex-grow p-4 overflow-y-auto no-scrollbar">
                {% for order in orders %}
                    {% if order.status == 'pending' %}
                        <!-- La tarjeta se renderizará aquí con JS -->
                    {% endif %}
                {% endfor %}
            </div>
        </div>
    
        <!-- Columna de Pedidos en Preparación -->
        <div class="w-1/2 flex flex-col">
            <div class="p-4 border-b border-gray-200 bg-gray-100">
                <h2 class="text-2xl font-bold text-center text-amber-800">En Preparación</h2>
            </div>
            <div id="preparing-orders" class="flex-grow p-4 overflow-y-auto no-scrollbar">
                {% for order in orders %}
                    {% if order.status == 'preparing' %}
                        <!-- La tarjeta se renderizará aquí con JS -->
                    {% endif %}
                {% endfor %}
            </div>
        </div>
    </div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const csrfToken = '{{ csrf_token }}';
        let initialOrders = {{ orders_json|safe }};
        
        // Cache de elementos del DOM para evitar múltiples queries
        const pendingContainer = document.getElementById('pending-orders');
        const preparingContainer = document.getElementById('preparing-orders');
        
        // Mapas para rastrear órdenes
        const orderCards = new Map();
        let timerInterval = null;
        let syncInterval = null;
        let lastSyncTimestamp = 0;

        // --- Funciones de Renderizado ---
        function renderOrderCard(order) {
            const itemsHtml = order.items.map(item => `
                <li class="flex flex-col">
                    <div class="flex justify-between items-center">
                        <span class="font-semibold ${item.is_prepared ? 'text-gray-400 line-through' : ''}">${item.quantity}x ${item.name}</span>
                        ${item.is_prepared ? '<span class="text-xs bg-green-200 text-green-800 px-2 py-1 rounded">Preparado</span>' : ''}
                    </div>
                    ${item.note ? `<p class="text-xs text-red-600 italic mt-1 pl-2 border-l-2 border-red-600">Nota: ${item.note}</p>` : ''}
                </li>
            `).join('');

            const card = document.createElement('div');
            card.id = `order-${order.id}`;
            card.className = 'order-card bg-white rounded-lg shadow-lg p-5 mb-4';
            card.dataset.createdAt = order.created_at;
            card.dataset.orderId = order.id;
            card.dataset.orderStatus = order.status;

            card.innerHTML = `
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-xl font-bold text-gray-800">Pedido #${order.id}</h3>
                    <span class="timer font-mono text-lg font-semibold text-gray-700">00:00</span>
                </div>
                <p class="text-md text-gray-600 mb-3">Para: <span class="font-semibold">${order.identifier}</span></p>
                <ul class="space-y-2 mb-4">${itemsHtml}</ul>
                <div class="flex justify-end space-x-3 mt-4">
                    ${order.status === 'pending' ? `<button class="start-btn bg-amber-700 text-white px-5 py-2 rounded-lg font-semibold hover:bg-amber-800" data-order-id="${order.id}">Empezar Preparación</button>` : ''}
                    ${order.status === 'preparing' ? `<button class="ready-btn bg-green-900 text-white px-5 py-2 rounded-lg font-semibold hover:bg-green-800" data-order-id="${order.id}">Marcar como Listo</button>` : ''}
                </div>
            `;
            
            orderCards.set(order.id, card);
            return card;
        }

        function addOrderToDOM(order) {
            if (orderCards.has(order.id)) return; // Evitar duplicados
            
            const card = renderOrderCard(order);
            const container = order.status === 'pending' ? pendingContainer : preparingContainer;
            if (container) {
                container.prepend(card);
            }
        }

        function moveOrderToPreparing(orderId) {
            const card = orderCards.get(orderId);
            if (card) {
                card.setAttribute('data-order-status', 'preparing');
                preparingContainer.prepend(card);
            }
        }

        function removeOrderFromDOM(orderId) {
            const card = orderCards.get(orderId);
            if (card) {
                card.style.opacity = '0';
                card.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    card.remove();
                    orderCards.delete(orderId);
                }, 500);
            }
        }

        // --- Lógica de Eventos y API ---
        async function updateOrderStatus(orderId, newStatus) {
            try {
                const response = await fetch(`/restaurant/api/orders/${orderId}/status/`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken,
                    },
                    body: JSON.stringify({ status: newStatus }),
                });
                if (!response.ok) throw new Error('Error al actualizar el estado');
            } catch (error) {
                console.error('Error:', error);
                showToast('Error al actualizar el pedido.', 'error');
            }
        }

        document.body.addEventListener('click', function(e) {
            if (e.target.matches('.start-btn')) {
                const orderId = parseInt(e.target.dataset.orderId, 10);
                updateOrderStatus(orderId, 'preparing');
            } else if (e.target.matches('.ready-btn')) {
                const orderId = parseInt(e.target.dataset.orderId, 10);
                updateOrderStatus(orderId, 'ready');
            }
        });

        // --- Temporizadores y Actualizaciones de UI ---
        const colorThresholds = [
            { minutes: 15, class: 'order-card-critical' },
            { minutes: 10, class: 'order-card-urgent' },
            { minutes: 7, class: 'order-card-old' },
            { minutes: 5, class: 'order-card-medium' },
            { minutes: 0, class: 'order-card-new' }
        ];

        function updateTimers() {
            const now = new Date();
            
            orderCards.forEach((card) => {
                const createdAt = new Date(card.dataset.createdAt);
                const diffSeconds = Math.floor((now - createdAt) / 1000);
                const minutes = Math.floor(diffSeconds / 60);
                const seconds = diffSeconds % 60;
                
                const timerEl = card.querySelector('.timer');
                if (timerEl) {
                    timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }

                // Actualizar color según antigüedad
                for (const threshold of colorThresholds) {
                    if (minutes >= threshold.minutes) {
                        card.className = 'order-card bg-white rounded-lg shadow-lg p-5 mb-4 ' + threshold.class;
                        break;
                    }
                }
            });
        }

        // --- Lógica de Pusher para Tiempo Real ---
        function setupPusher() {
            if (!PUSHER_KEY) {
                console.warn("Pusher key no está configurada. Usando polling.");
                return;
            }

            const pusher = new Pusher(PUSHER_KEY, { cluster: PUSHER_CLUSTER });
            const channel = pusher.subscribe('cocina-channel');

            channel.bind('nuevo-pedido', function(data) {
                showToast(`Nuevo pedido para ${data.order.identifier}`, 'info');
                addOrderToDOM(data.order);
            });

            channel.bind('actualizacion-estado', function(data) {
                const order = data.order;
                if (order.status === 'preparing') {
                    moveOrderToPreparing(order.id);
                } else if (['ready', 'cancelled'].includes(order.status)) {
                    removeOrderFromDOM(order.id);
                }
            });
        }

        // --- Polling automático como backup ---
        async function syncOrdersWithServer() {
            try {
                const now = Date.now();
                if (now - lastSyncTimestamp < 1500) return;
                lastSyncTimestamp = now;

                const response = await fetch("{% url 'restaurant:api_orders' %}");
                if (!response.ok) return;
                
                const newOrders = await response.json();
                
                // Crear mapa de órdenes del servidor
                const serverOrderMap = new Map(newOrders.map(o => [o.id, o]));
                
                // Procesar órdenes del servidor
                serverOrderMap.forEach((order, orderId) => {
                    const card = orderCards.get(orderId);
                    
                    if (!card) {
                        addOrderToDOM(order);
                    } else {
                        const currentStatus = card.dataset.orderStatus;
                        if (currentStatus !== order.status) {
                            if (order.status === 'preparing') {
                                moveOrderToPreparing(orderId);
                            } else if (['ready', 'cancelled'].includes(order.status)) {
                                removeOrderFromDOM(orderId);
                            }
                        }
                    }
                });
                
                // Remover órdenes que ya no existen en el servidor
                orderCards.forEach((card, orderId) => {
                    if (!serverOrderMap.has(orderId)) {
                        removeOrderFromDOM(orderId);
                    }
                });
            } catch (error) {
                console.error('Sync error:', error.message);
            }
        }

        // --- Inicialización ---
        initialOrders.forEach(addOrderToDOM);
        timerInterval = setInterval(updateTimers, 1000);
        syncInterval = setInterval(syncOrdersWithServer, 2000);
        setupPusher();
        syncOrdersWithServer();
        
        // Cleanup al descargar
        window.addEventListener('beforeunload', function() {
            clearInterval(timerInterval);
            clearInterval(syncInterval);
        });
    });
</script>
{% endblock %}
